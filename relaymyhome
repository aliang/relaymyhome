#!/usr/bin/env bash

# The MIT License (MIT)
#
# Copyright (c) 2015 Alvin Liang
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

# RelayMyHome 3.0.1
# This fork by Alvin Liang (https://github.com/aliang)
# See other generous contributors, plus view the source, readme, and license
# at https://github.com/aliang/relaymyhome

# Original script by Rob Zimmerman (https://www.github.com/taintedzodiac)
# Original script located at https://github.com/taintedzodiac/relaymyhome
# See LICENSE for the previous license

# Tested in OS X 10.9.5 (Mavericks)

# Might need this for config files
# echo $BASH_SOURCE
# echo `dirname $BASH_SOURCE`

function log () {
    if [[ $VERBOSITY -eq 1 ]]; then
        echo "$@"
    fi
}

function notify {
    if [ -z ${SPEAK} ] ; then
        echo "${@}" ;
    else
        say "${@}" ;
    fi
    return 0
}

# Pauses for X seconds
function pause_with_progress_dots {
    local pause_time
    pause_time=$1
    local pause_count
    pause_count=1
    while [ $pause_count -le $pause_time ]; do
        printf "."
        sleep 1
        pause_count=$((pause_count+1))
    done
    printf "\n"
}

function disassociate_from_wifi_network {
    printf "Disassociating from Wi-Fi network"
    disassociate_from_wifi_network_silently
    pause_with_progress_dots $SLEEP_TIME
}

function disassociate_from_wifi_network_silently {
    /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -z
}

function turn_off_wifi {
    printf "Turning off Wi-Fi" # for ${SLEEP_TIME} seconds"
    networksetup -setairportpower $wifi off
    pause_with_progress_dots $SLEEP_TIME
}

function turn_on_wifi {
    printf "Turning on Wi-Fi"
    networksetup -setairportpower $wifi on
    pause_with_progress_dots $SLEEP_TIME
}

# Cycle Wi-Fi
function cycle_wifi {
    turn_off_wifi
    turn_on_wifi
    echo "Wi-Fi cycle completed"
}

function unload_internet_sharing {
    if $(launchctl list | grep -q com.apple.InternetSharing.plist); then
        printf "Unloading Internet Sharing plist"
        launchctl unload -w /System/Library/LaunchDaemons/com.apple.InternetSharing.plist
        pause_with_progress_dots $SLEEP_TIME
    else
        echo "Internet Sharing plist not loaded"
    fi
}

# Turn off Internet Sharing if on
function turn_off_internet_sharing {
    killall InternetSharing
}

function turn_on_internet_sharing {
    /usr/libexec/InternetSharing &
}

function set_mac_address {
    local targetMAC
    targetMAC=$1
    ifconfig $wifi ether $targetMAC
}

# Stores the current mac address to $currentMAC as uppercase.
function store_current_mac_address {
    currentMAC=$(ifconfig ${wifi} ether | grep ether | awk '{print $2}' | tr '[:lower:]' '[:upper:]')
}

# Sets the mac address. Stores the resulting mac address to $currentMAC.
# Assumes the wifi is on
function set_and_store_current_mac_address {
    local targetMAC
    targetMAC=$1
    disassociate_from_wifi_network_silently
    set_mac_address $targetMAC
    store_current_mac_address
}

function dump_ifconfig {
    echo "Here is the output of ifconfig $wifi:"
    echo `ifconfig $wifi`
    echo "--------"
}

# Sets the mac address repeatedly until it sticks
# Stores the resulting mac address to $currentMAC
function set_and_wait_for_mac_address_change {
    echo "Setting and waiting for MAC address to change"
    local targetMAC
    targetMAC=$1
    local wait_count
    wait_count=1
    while [ $targetMAC != $currentMAC ] && [ $wait_count -le $WAIT_TRIES ]; do
        printf "\rAttempt $wait_count of $WAIT_TRIES ($currentMAC -> $targetMAC)"
        sleep 1
        set_and_store_current_mac_address $targetMAC
        wait_count=$((wait_count+1))
    done
    printf "\n"
    if [ $targetMAC != $currentMAC ]; then
        echo "MAC addresses didn't match"
    fi
    echo "MAC address is now $currentMAC"
}

# Run everything we need to spoof the mac address.
function spoof_mac_address {
    local targetMAC
    targetMAC=$1
    # echo "Setting address to $targetMAC"

    # Turn on wifi
    turn_on_wifi
    disassociate_from_wifi_network
    unload_internet_sharing
    turn_off_internet_sharing
    set_and_wait_for_mac_address_change $targetMAC
    cycle_wifi
}

function wait_for_streetpasses {
    turn_on_internet_sharing
    echo "Pausing to allow connections for ${RELAY_TIME} seconds"
    pause_with_progress_dots $RELAY_TIME
}

function spoof_full_list_of_mac_addresses {
    # Generate a full list of 160 MACs when "full" mode is specified
    # To use full mode: ./relaymyhome full
    # Check the repo at github for more information.

    # Set the base MAC address
    baseAddr="4E:53:50:4F:4F:"

    # Create an array for the last octet of the mac address, limited range.
    Addr=($(for X in {0..159} ; do echo ${X} | awk '{printf "%s%02X ", "4E:53:50:4F:4F:", $1}'; done ;))

    if [ -z ${count} ]; then
        num=5
    else
        num=${count}
    fi
    echo "Full Mode enabled. Randomly seeding ${num} addresses from full list."

    # TODO: Back up existing Internet Sharing plist (this would allow us to set the SSID)
    # TODO: Copy settings in place of existing Internet Sharing plist

    for ((a=1; a<=$num; a++));
    do
        selectedAddr=${Addr[$RANDOM % ${#Addr[@]} ]}
        echo "-----------------------------------------------"
        echo "Spoofing $wifi to $selectedAddr ($a of $num)"
        echo "-----------------------------------------------"
        spoof_mac_address $selectedAddr
        wait_for_streetpasses
    done
}

function reset_mac_address {
    spoof_mac_address $WirelessMAC
}

# Taken from http://mywiki.wooledge.org/BashFAQ/026
# Shuffles the contents of ADDRESSES
function shuffle_addresses() {
    log "Shuffling addresses"
    local i tmp size max rand

    # $RANDOM % (i+1) is biased because of the limited range of $RANDOM
    # Compensate by using a range which is a multiple of the array size.
    size=${#ADDRESSES[*]}
    max=$(( 32768 / size * size ))

    for ((i=size-1; i>0; i--)); do
        while (( (rand=$RANDOM) >= max )); do :; done
        rand=$(( rand % (i+1) ))
        tmp=${ADDRESSES[i]} ADDRESSES[i]=${ADDRESSES[rand]} ADDRESSES[rand]=$tmp
    done
}

# Sets ADDRESSES to the first n elements of ADDRESSES
# Not used yet
function set_addresses_to_subset {
    local size index
    size=$1
    if [[ $size -le 1 ]]; then
        index=0
    else
        index=$((size-1))
    fi
    ADDRESSES=${ADDRESSES[@]:0:index}
}

# Sets ADDRESSES to the 'full' list of 160 MAC addresses
# Not used yet
function set_addresses_for_full_mode {
    local base_address
    # Set the base MAC address (not used!)
    base_address="4E:53:50:4F:4F:"

    # Create an array for the last octet of the mac address, limited range.
    ADDRESSES=($(for X in {0..159} ; do echo ${X} | awk '{printf "%s%02X ", "4E:53:50:4F:4F:", $1}'; done ;))
}

function spoof_full_mode_addresses {
    local a num selectedAddr
    if [ -z ${COUNT} ]; then
        num=5
    else
        num=${COUNT}
    fi

    echo "Full Mode enabled. Randomly seeding ${num} addresses from full list."
    for ((a=1; a<=$num; a++));
    do
        selectedAddr=${Addr[$RANDOM % ${#Addr[@]} ]}
        echo "-----------------------------------------------"
        echo "Spoofing $wifi to $selectedAddr ($a of $num)"
        echo "-----------------------------------------------"
        spoof_mac_address $selectedAddr
        wait_for_streetpasses
    done
}

function set_addresses_for_nintendo {
    # Taken from: https://docs.google.com/spreadsheet/ccc?key=0AvvH5W4E2lIwdEFCUkxrM085ZGp0UkZlenp6SkJablE#gid=0
    # TODO: Read this from a file
    ADDRESSES=()
    ADDRESSES[0]='00:0D:67:15:2D:82'
    ADDRESSES[1]='00:0D:67:15:D7:21'
    ADDRESSES[2]='00:0D:67:15:D5:44'
    ADDRESSES[3]='00:0D:67:15:D2:59'
    ADDRESSES[4]='00:0D:67:15:D6:FD'
}

function spoof_nintendo_mac_addresses {
    echo "Connecting to the five Nintendo World relays."
    set_addresses_for_nintendo
    spoof_addresses
}

function set_addresses_for_homepass {
    ADDRESSES=()
    ADDRESSES[0]='4E:53:50:4F:4F:40'
    ADDRESSES[1]='4E:53:50:4F:4F:41'
    ADDRESSES[2]='4E:53:50:4F:4F:42'
    ADDRESSES[3]='4E:53:50:4F:4F:43'
    ADDRESSES[4]='4E:53:50:4F:4F:44'
    ADDRESSES[5]='4E:53:50:4F:4F:45'
    ADDRESSES[6]='4E:53:50:4F:4F:46'
    ADDRESSES[7]='4E:53:50:4F:4F:47'
    ADDRESSES[8]='4E:53:50:4F:4F:48'
    ADDRESSES[9]='4E:53:50:4F:4F:49'
    ADDRESSES[10]='4E:53:50:4F:4F:4A'
    ADDRESSES[11]='4E:53:50:4F:4F:4B'
    ADDRESSES[12]='4E:53:50:4F:4F:4C'
    ADDRESSES[13]='4E:53:50:4F:4F:4D'
    ADDRESSES[14]='4E:53:50:4F:4F:4E'
    ADDRESSES[15]='4E:53:50:4F:4F:4F'
}

function spoof_homepass_mac_addresses {
    echo "Connecting to the sixteen Homepass relays."
    set_addresses_for_homepass
    spoof_addresses
}

function set_addresses_to_sequence_of_16 {
    local base_address
    base_address=$1
    # Sort of like this:
    # # ADDRESSES=($(for X in {0..15} ; do echo ${X} | awk '{printf "%s%01X ", "4E:53:50:4F:4F:0", $1}'; done ;))
    ADDRESSES=($(for X in {0..15} ; do echo $base_address ${X} | awk '{printf "%s%01X ", $1, $2}'; done ;))
}

function spoof_addresses_for_shirt_color {
    echo "Connecting to the $1 shirt Mii relays."
    set_addresses_for_shirt_color $1
    spoof_addresses
}

function set_addresses_for_shirt_color {
    if [[ $1 == 'red' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:0"
    elif [[ $1 == 'orange' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:1"
    elif [[ $1 == 'yellow' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:2"
    elif [[ $1 == 'light_green' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:3"
    elif [[ $1 == 'green' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:4"
    elif [[ $1 == 'blue' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:5"
    elif [[ $1 == 'light_blue' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:6"
    elif [[ $1 == 'pink' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:7"
    elif [[ $1 == 'purple' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:8"
    elif [[ $1 == 'brown' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:9"
    elif [[ $1 == 'white' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:A"
    elif [[ $1 == 'black' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:43:B"
    else
        echo "Didn't recognize the shirt color $1"
        ADDRESSES=()
    fi
}

function spoof_addresses_for_gender {
    echo "Connecting to the $1 gender Mii relays."
    set_addresses_for_gender $1
    spoof_addresses
}

function set_addresses_for_gender {
    if [[ $1 == 'male' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:42:0"
    elif [[ $1 == 'female' ]]; then
        set_addresses_to_sequence_of_16 "4E:53:50:4F:42:1"
    else
        echo "Didn't recognize the gender $1"
        ADDRESSES=()
    fi
}

# Spoof whatever is in the array ADDRESSES
function spoof_addresses {
    local n
    n=1
    if [[ $SHUFFLE -eq 1 ]]; then
        shuffle_addresses
    fi
    # if [[ -z ${COUNT+x} ]]; then
    #     echo "no-op"
    # else
    #     set_addresses_to_subset $COUNT
    # fi
    # Won't run if COUNT is zero, which is ok
    if [[ -n ${COUNT} ]]; then
        set_addresses_to_subset $COUNT
    fi
    for a in "${ADDRESSES[@]}"; do
        echo "-----------------------------------------------"
        echo "Spoofing $wifi to $a ($n of ${#ADDRESSES[@]})"
        echo "-----------------------------------------------"
        spoof_mac_address $a
        wait_for_streetpasses
        n=$((n+1))
    done
}

function cleanup {
    reset_mac_address
    turn_off_internet_sharing

    echo "Cycling of Relays has completed, MAC address reverted."
    notify "Time to check your StreetPasses!"
    return 0
}

function ctrl_c {
    # user quit midway through, so we should revert
    # the MAC address by calling our cleanup function
    echo "*** Interrupted, cleaning up ***"
    cleanup
    exit $?
}

# TODO: Shuffling doesn't work for 'full' mode, since it's already shuffled
# TODO: Implement count for everything

function usage {
    echo "$0 [-c count] [-s] [-t time] [-r] [-v] [ADDRESS]"
    echo "  -c: number of MAC addresses to spoof (full mode only, default 5)"
    echo "  -s: audibly speak when the script is done"
    echo "  -t: time (s) to wait for connections on each MAC address (default 90)"
    echo "  -r: randomize address spoofing order"
    echo "  -v: run in verbose mode"
    echo "ADDRESS can be 'full', 'nintendo', 'homepass', 'cleanup',"
    echo "  or mutiple addresses in the form 'XX:XX:XX:XX:XX:XX'"
    echo "  or 'shirt' followed by a shirt color (like 'red' or 'light_blue')"
    echo "  or 'gender' followed by 'male' or 'female'"
    echo "Please note that this script must be run as root."
}

# trap keyboard interrupt (control-c) or unexpected quit
trap ctrl_c SIGINT SIGTERM

# These will be overridden by getopts
VERBOSITY=0
SPEAK=0
SHUFFLE=0
# How long we will pause on each MAC address (seconds)
RELAY_TIME=90
# How long to wait between Wi-Fi configuration steps (seconds)
SLEEP_TIME=1
# Number of tries to set the MAC address before giving up
# (1 second between tries)
WAIT_TRIES=30
# How many addresses of the set to spoof. If null or 0, then spoof them all
COUNT=0

while getopts hvsrc:t: option
do
    case "${option}" in
        h) usage ; exit ;;
        v) VERBOSITY=1 ;;
        s) SPEAK=1 ;;
        r) SHUFFLE=1 ;;
        c) count=${OPTARG} ;;
        t) RELAY_TIME=${OPTARG} ;;
        *) usage ; exit 1 ;
    esac
done

shift $(( OPTIND - 1 ))

echo "To view advanced usage, type '$0 -h'"

if [ $EUID != 0 ]; then
    # echo "---------------------------------------"
    echo "You must be root to run this script."
    echo "Try running 'sudo $0'."
    # echo "Running again with sudo."
    # echo "Please enter your password if prompted."
    # echo "---------------------------------------"
    # sudo "$0" "$@"
    # exit $?
    exit 1;
fi

wservice=`/usr/sbin/networksetup -listallnetworkservices | grep -Ei '(wi-fi|airport)'`
# Wi-Fi interface name, used in all sorts of commands
wifi=$(networksetup -listallhardwareports | awk "/$wservice/,/Ethernet/"' getline { print $2 }')
# Original hardware MAC address, uppercase
WirelessMAC=$(networksetup -getmacaddress "${wifi}" | awk '{print $3}' | tr '[:lower:]' '[:upper:]')
# Variable to store the current spoofed MAC address.
# Used to poll for whether the MAC was set successfully
currentMAC=$WirelessMAC

log "Wi-Fi adapter is: $wifi"
log "Original MAC address is: $WirelessMAC"

if [[ $1 == "full" ]]; then
    spoof_full_list_of_mac_addresses
elif [[ $1 == "nintendo" ]]; then
    spoof_nintendo_mac_addresses
elif [[ $1 == "homepass" ]]; then
    spoof_homepass_mac_addresses
elif [[ $1 == "shirt" ]]; then
    if [[ -n $2 ]]; then
        spoof_addresses_for_shirt_color $2
    else
        echo "No shirt color specified"
        exit 1
    fi
elif [[ $1 == "gender" ]]; then
    if [[ -n $2 ]]; then
        spoof_addresses_for_gender $2
    else
        echo "No gender specified"
        exit 1
    fi
elif [[ $1 == "cleanup" ]]; then
    echo "Not doing anything, only cleaning up"
elif [[ -n $1 ]]; then
    ADDRESSES=("$@")
    spoof_addresses
else
    spoof_nintendo_mac_addresses
    spoof_homepass_mac_addresses
fi

# ... and we are done

cleanup
